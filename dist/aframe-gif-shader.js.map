{"version":3,"file":"aframe-gif-shader.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO,+CAA+C;AAChE,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO,iDAAiD;AAChE;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;UCvFA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACN2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,WAAW;AACnB,QAAQ,QAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,WAAW,eAAe;AAC1B;AACA;AACA,WAAW,eAAe;AAC1B,gBAAgB,eAAe;AAC/B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qBAAqB;AACvE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa,SAAS,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAQ;AAChB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA,mCAAmC;AACnC,aAAa;AACb,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,MAAM,aAAa;AACnB,eAAe;AACf;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,WAAW;AACX;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC","sources":["webpack://aframe-gif-shader/./lib/gifsparser.js","webpack://aframe-gif-shader/webpack/bootstrap","webpack://aframe-gif-shader/webpack/runtime/make namespace object","webpack://aframe-gif-shader/./index.js"],"sourcesContent":["/**\r\n * \r\n * Gif parser by @gtk2k\r\n * https://github.com/gtk2k/gtk2k.github.io/tree/master/animation_gif\r\n *\r\n */\r\n\r\nexports.parseGIF = function (gif, successCB, errorCB) {\r\n\r\n  var pos = 0;\r\n  var delayTimes = [];\r\n  var loadCnt = 0;\r\n  var graphicControl = null;\r\n  var imageData = null;\r\n  var frames = [];\r\n  var loopCnt = 0;\r\n  if (gif[0] === 0x47 && gif[1] === 0x49 && gif[2] === 0x46 && // 'GIF'\r\n    gif[3] === 0x38 && (gif[4] === 0x39 || gif[4] === 0x37) && gif[5] === 0x61) { // '89a'\r\n    pos += 13 + (+!!(gif[10] & 0x80) * Math.pow(2, (gif[10] & 0x07) + 1) * 3);\r\n    var gifHeader = gif.subarray(0, pos);\r\n    while (gif[pos] && gif[pos] !== 0x3b) {\r\n      var offset = pos, blockId = gif[pos];\r\n      if (blockId === 0x21) {\r\n        var label = gif[++pos];\r\n        if ([0x01, 0xfe, 0xf9, 0xff].indexOf(label) !== -1) {\r\n          label === 0xf9 && (delayTimes.push((gif[pos + 3] + (gif[pos + 4] << 8)) * 10));\r\n          label === 0xff && (loopCnt = gif[pos + 15] + (gif[pos + 16] << 8));\r\n          while (gif[++pos]) pos += gif[pos];\r\n          label === 0xf9 && (graphicControl = gif.subarray(offset, pos + 1));\r\n        } else { errorCB && errorCB('parseGIF: unknown label'); break; }\r\n      } else if (blockId === 0x2c) {\r\n        pos += 9;\r\n        pos += 1 + (+!!(gif[pos] & 0x80) * (Math.pow(2, (gif[pos] & 0x07) + 1) * 3));\r\n        while (gif[++pos]) pos += gif[pos];\r\n        var imageData = gif.subarray(offset, pos + 1);\r\n        // Each frame should have an image and a flag to indicate how to dispose it.\r\n        var frame = {\r\n          // http://matthewflickinger.com/lab/whatsinagif/animation_and_transparency.asp\r\n          // Disposal method is a flag stored in the 3rd byte of the graphics control\r\n          // This byte is packed and stores more information, only 3 bits of it represent the disposal\r\n          disposalMethod: graphicControl[3],\r\n          blob:URL.createObjectURL(new Blob([gifHeader, graphicControl, imageData]))\r\n        }\r\n        frames.push(frame);\r\n      } else { errorCB && errorCB('parseGIF: unknown blockId'); break; }\r\n      pos++;\r\n    }\r\n  } else { errorCB && errorCB('parseGIF: no GIF89a'); }\r\n  if (frames.length) {\r\n\r\n    var cnv = document.createElement('canvas');      \r\n    var loadImg = function () {\r\n      for(var i = 0; i < frames.length; i++){\r\n        var img = new Image();\r\n        img.onload = function (e, i) {\r\n          if (i === 0) {\r\n            cnv.width = img.width\r\n            cnv.height = img.height\r\n          }\r\n          loadCnt++;\r\n          frames[i] = this;\r\n          if (loadCnt === frames.length) {\r\n            loadCnt = 0;\r\n            imageFix(1);\r\n          }\r\n        }.bind(img, null, i);\r\n        // Link html image tag with the extracted GIF Frame \r\n        img.src = frames[i].blob;\r\n        img.disposalMethod = frames[i].disposalMethod;\r\n      }\r\n    }\r\n    var imageFix = function (i) {\r\n      var img = new Image();\r\n      img.onload = function (e, i) {\r\n        loadCnt++;\r\n        frames[i] = this;\r\n        if (loadCnt === frames.length) {\r\n          cnv = null;\r\n          successCB && successCB(delayTimes, loopCnt, frames);\r\n        } else {\r\n          imageFix(++i);\r\n        }\r\n      }.bind(img);\r\n      img.src = cnv.toDataURL('image/gif');\r\n    }\r\n    loadImg();\r\n  }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { parseGIF } from './lib/gifsparser'\r\n\r\nif (typeof AFRAME === 'undefined') {\r\n  throw 'Component attempted to register before AFRAME was available.'\r\n}\r\n\r\n/* get util from AFRAME */\r\nconst { parseUrl } = AFRAME.utils.srcLoader\r\nconst { debug } = AFRAME.utils\r\n// debug.enable('shader:gif:*')\r\ndebug.enable('shader:gif:warn')\r\nconst warn = debug('shader:gif:warn')\r\nconst log = debug('shader:gif:debug')\r\n\r\n/* store data so that you won't load same data */\r\nconst gifData = {}\r\n\r\n/* create error message */\r\nfunction createError (err, src) {\r\n  return { status: 'error', src: src, message: err, timestamp: Date.now() }\r\n}\r\n\r\nAFRAME.registerShader('gif', {\r\n\r\n  /**\r\n   * For material component:\r\n   * @see https://github.com/aframevr/aframe/blob/60d198ef8e2bfbc57a13511ae5fca7b62e01691b/src/components/material.js\r\n   * For example of `registerShader`:\r\n   * @see https://github.com/aframevr/aframe/blob/41a50cd5ac65e462120ecc2e5091f5daefe3bd1e/src/shaders/flat.js\r\n   * For MeshBasicMaterial\r\n   * @see http://threejs.org/docs/#Reference/Materials/MeshBasicMaterial\r\n   */\r\n  schema: {\r\n\r\n    /* For material */\r\n    color: { type: 'color' },\r\n    fog: { default: true },\r\n\r\n    /* For texuture */\r\n    src: { default: null },\r\n    autoplay: { default: true },\r\n\r\n  },\r\n\r\n  /**\r\n   * Initialize material. Called once.\r\n   * @protected\r\n   */\r\n  init (data) {\r\n    log('init', data)\r\n    log(this.el.components)\r\n    this.__cnv = document.createElement('canvas')\r\n    this.__cnv.width = 2\r\n    this.__cnv.height = 2\r\n    this.__ctx = this.__cnv.getContext('2d')\r\n    this.__texture = new THREE.Texture(this.__cnv) //renders straight from a canvas\r\n    if (data.repeat) {\r\n      this.__texture.wrapS = THREE.RepeatWrapping;\r\n      this.__texture.wrapT = THREE.RepeatWrapping;\r\n      this.__texture.repeat.set( data.repeat.x, data.repeat.y );\r\n    }\r\n    this.__material = {}\r\n    this.__reset()\r\n    this.material = new THREE.MeshBasicMaterial({ map: this.__texture })\r\n    this.el.sceneEl.addBehavior(this)\r\n    return this.material\r\n  },\r\n\r\n  /**\r\n   * Update or create material.\r\n   * @param {object|null} oldData\r\n   */\r\n  update (oldData) {\r\n    log('update', oldData)\r\n    this.__updateMaterial(oldData)\r\n    this.__updateTexture(oldData)\r\n    return this.material\r\n  },\r\n\r\n  /**\r\n   * Called on each scene tick.\r\n   * @protected\r\n   */\r\n  tick (t) {\r\n    if (!this.__frames || this.paused()) return\r\n    if (Date.now() - this.__startTime >= this.__nextFrameTime) {\r\n      this.nextFrame()\r\n    }\r\n  },\r\n\r\n  /*================================\r\n  =            material            =\r\n  ================================*/\r\n\r\n  /**\r\n   * Updating existing material.\r\n   * @param {object} data - Material component data.\r\n   */\r\n  __updateMaterial (data) {\r\n    const { material } = this\r\n    const newData = this.__getMaterialData(data)\r\n    Object.keys(newData).forEach(key => {\r\n      material[key] = newData[key]\r\n    })\r\n  },\r\n\r\n\r\n  /**\r\n   * Builds and normalize material data, normalizing stuff along the way.\r\n   * @param {Object} data - Material data.\r\n   * @return {Object} data - Processed material data.\r\n   */\r\n  __getMaterialData (data) {\r\n    return {\r\n      fog: data.fog,\r\n      color: new THREE.Color(data.color),\r\n    }\r\n  },\r\n\r\n\r\n  /*==============================\r\n  =            texure            =\r\n  ==============================*/\r\n\r\n  /**\r\n   * set texure\r\n   * @private\r\n   * @param {Object} data\r\n   * @property {string} status - success / error\r\n   * @property {string} src - src url\r\n   * @property {array} times - array of time length of each image\r\n   * @property {number} cnt - total counts of gif images\r\n   * @property {array} frames - array of each image\r\n   * @property {Date} timestamp - created at the texure\r\n   */\r\n\r\n  __setTexure (data) {\r\n    log('__setTexure', data)\r\n    if (data.status === 'error') {\r\n      warn(`Error: ${data.message}\\nsrc: ${data.src}`)\r\n      this.__reset()\r\n    }\r\n    else if (data.status === 'success' && data.src !== this.__textureSrc) {\r\n      this.__reset()\r\n      /* Texture added or changed */\r\n      this.__ready(data)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update or create texure.\r\n   * @param {Object} data - Material component data.\r\n   */\r\n  __updateTexture (data) {\r\n    const { src, autoplay } = data\r\n\r\n    /* autoplay */\r\n    if (typeof autoplay === 'boolean') {\r\n      this.__autoplay = autoplay\r\n    }\r\n    else if (typeof autoplay === 'undefined') {\r\n      this.__autoplay = true\r\n    }\r\n    if (this.__autoplay && this.__frames) { this.play() }\r\n\r\n    /* src */\r\n    if (src) {\r\n      this.__validateSrc(src, this.__setTexure.bind(this))\r\n    } else {\r\n      /* Texture removed */\r\n      this.__reset()\r\n    }\r\n  },\r\n\r\n  /*=============================================\r\n  =            varidation for texure            =\r\n  =============================================*/\r\n\r\n  __validateSrc (src, cb) {\r\n\r\n    /* check if src is a url */\r\n    const url = parseUrl(src)\r\n    if (url) {\r\n      this.__getImageSrc(url, cb)\r\n      return\r\n    }\r\n\r\n    let message\r\n\r\n    /* check if src is a query selector */\r\n    const el = this.__validateAndGetQuerySelector(src)\r\n    if (!el || typeof el !== 'object') { return }\r\n    if (el.error) {\r\n      message = el.error\r\n    }\r\n    else {\r\n      const tagName = el.tagName.toLowerCase()\r\n      if (tagName === 'video') {\r\n        src = el.src\r\n        message = 'For video, please use `aframe-video-shader`'\r\n      }\r\n      else if (tagName === 'img') {\r\n        this.__getImageSrc(el.src, cb)\r\n        return\r\n      }\r\n      else {\r\n        message = `For <${tagName}> element, please use \\`aframe-html-shader\\``\r\n      }\r\n    }\r\n\r\n    /* if there is message, create error data */\r\n    if (message) {\r\n      const srcData = gifData[src]\r\n      const errData = createError(message, src)\r\n      /* callbacks */\r\n      if (srcData && srcData.callbacks) {\r\n        srcData.callbacks.forEach(cb => cb(errData))\r\n      }\r\n      else {\r\n        cb(errData)\r\n      }\r\n      /* overwrite */\r\n      gifData[src] = errData\r\n    }\r\n\r\n  },\r\n\r\n  /**\r\n   * Validate src is a valid image url\r\n   * @param  {string} src - url that will be tested\r\n   * @param  {function} cb - callback with the test result\r\n   */\r\n  __getImageSrc (src, cb) {\r\n\r\n    /* if src is same as previous, ignore this */\r\n    if (src === this.__textureSrc) { return }\r\n\r\n    /* check if we already get the srcData */\r\n    let srcData = gifData[src]\r\n    if (!srcData || !srcData.callbacks) {\r\n      /* create callback */\r\n      srcData = gifData[src] = { callbacks: [] }\r\n      srcData.callbacks.push(cb)\r\n    }\r\n    else if (srcData.src) {\r\n      cb(srcData)\r\n      return\r\n    }\r\n    else if (srcData.callbacks) {\r\n      /* add callback */\r\n      srcData.callbacks.push(cb)\r\n      return\r\n    }\r\n    const tester = new Image()\r\n    tester.crossOrigin = 'Anonymous'\r\n    tester.addEventListener('load', e => {\r\n      /* check if it is gif */\r\n      this.__getUnit8Array(src, arr => {\r\n        if (!arr) {\r\n          onError('This is not gif. Please use `shader:flat` instead')\r\n          return\r\n        }\r\n        /* parse data */\r\n        parseGIF(arr, (times, cnt, frames) => {\r\n          /* store data */\r\n          const newData = { status: 'success', src: src, times: times, cnt: cnt, frames: frames, timestamp: Date.now() }\r\n          /* callbacks */\r\n          if (srcData.callbacks) {\r\n            srcData.callbacks.forEach(cb => cb(newData))\r\n            /* overwrite */\r\n            gifData[src] = newData\r\n          }\r\n        }, (err) => onError(err))\r\n      })\r\n    })\r\n    tester.addEventListener('error', e => onError('Could be the following issue\\n - Not Image\\n - Not Found\\n - Server Error\\n - Cross-Origin Issue'))\r\n    function onError(message) {\r\n      /* create error data */\r\n      const errData = createError(message, src)\r\n      /* callbacks */\r\n      if (srcData.callbacks) {\r\n        srcData.callbacks.forEach(cb => cb(errData))\r\n        /* overwrite */\r\n        gifData[src] = errData\r\n      }\r\n    }\r\n    tester.src = src\r\n  },\r\n\r\n  /**\r\n   *\r\n   * get mine type\r\n   *\r\n   */\r\n  __getUnit8Array(src, cb) {\r\n    if (typeof cb !== 'function') { return }\r\n\r\n    const xhr = new XMLHttpRequest()\r\n    xhr.open('GET', src)\r\n    xhr.responseType = 'arraybuffer'\r\n    xhr.addEventListener('load', e => {\r\n      const uint8Array = new Uint8Array(e.target.response)\r\n      const arr = (uint8Array).subarray(0, 4)\r\n      // const header = arr.map(value => value.toString(16)).join('')\r\n      let header = ''\r\n      for(let i = 0; i < arr.length; i++) {\r\n        header += arr[i].toString(16)\r\n      }\r\n      if (header === '47494638') { cb(uint8Array) }\r\n      else { cb() }\r\n    })\r\n    xhr.addEventListener('error', e => {\r\n      log(e)\r\n      cb()\r\n    })\r\n    xhr.send()\r\n  },\r\n\r\n\r\n  /**\r\n   * Query and validate a query selector,\r\n   *\r\n   * @param  {string} selector - DOM selector.\r\n   * @return {object} Selected DOM element | error message object.\r\n   */\r\n  __validateAndGetQuerySelector (selector) {\r\n    try {\r\n      var el = document.querySelector(selector)\r\n      if (!el) {\r\n        return { error: 'No element was found matching the selector' }\r\n      }\r\n      return el\r\n    } catch (e) {  // Capture exception if it's not a valid selector.\r\n      return { error: 'no valid selector' }\r\n    }\r\n  },\r\n\r\n\r\n  /*================================\r\n  =            playback            =\r\n  ================================*/\r\n\r\n  /**\r\n   * Pause gif\r\n   * @public\r\n   */\r\n  pause () {\r\n    log('pause')\r\n    this.__paused = true\r\n  },\r\n\r\n  /**\r\n   * Play gif\r\n   * @public\r\n   */\r\n  play () {\r\n    log('play')\r\n    this.__paused = false\r\n  },\r\n\r\n  /**\r\n   * Toggle playback. play if paused and pause if played.\r\n   * @public\r\n   */\r\n\r\n  togglePlayback () {\r\n\r\n    if (this.paused()) { this.play() }\r\n    else { this.pause() }\r\n\r\n  },\r\n\r\n  /**\r\n   * Return if the playback is paused.\r\n   * @public\r\n   * @return {boolean}\r\n   */\r\n  paused () {\r\n    return this.__paused\r\n  },\r\n\r\n\r\n  /**\r\n   * Go to next frame\r\n   * @public\r\n   */\r\n  nextFrame () {\r\n    this.__draw()\r\n\r\n    /* update next frame time */\r\n    while ((Date.now() - this.__startTime) >= this.__nextFrameTime) {\r\n\r\n      this.__nextFrameTime += this.__delayTimes[this.__frameIdx++]\r\n      if ((this.__infinity || this.__loopCnt) && this.__frameCnt <= this.__frameIdx) {\r\n        /* go back to the first */\r\n        this.__frameIdx = 0\r\n      }\r\n    }\r\n\r\n  },\r\n\r\n  /*==============================\r\n   =            canvas            =\r\n   ==============================*/\r\n\r\n  /**\r\n   * clear canvas\r\n   * @private\r\n   */\r\n  __clearCanvas () {\r\n    this.__ctx.clearRect(0, 0, this.__width, this.__height)\r\n    this.__texture.needsUpdate = true\r\n  },\r\n\r\n  /**\r\n   * draw\r\n   * @private\r\n   */\r\n  __draw () {\r\n    if(this.__frameIdx != 0){\r\n      const lastFrame = this.__frames[this.__frameIdx -1 ]\r\n      // Disposal method indicates if you should clear or not the background.\r\n      // This flag is represented in binary and is a packed field which can also represent transparency.\r\n      // http://matthewflickinger.com/lab/whatsinagif/animation_and_transparency.asp\r\n      if(lastFrame.disposalMethod == 8 || lastFrame.disposalMethod == 9){\r\n        this.__clearCanvas();\r\n      }\r\n    } else {\r\n      this.__clearCanvas();\r\n    }\r\n    const actualFrame = this.__frames[this.__frameIdx]\r\n    if(typeof actualFrame !== 'undefined') {\r\n      this.__ctx.drawImage(actualFrame, 0, 0, this.__width, this.__height)\r\n      this.__texture.needsUpdate = true\r\n    }\r\n  },\r\n\r\n  /*============================\r\n  =            ready            =\r\n  ============================*/\r\n\r\n  /**\r\n   * setup gif animation and play if autoplay is true\r\n   * @private\r\n   * @property {string} src - src url\r\n   * @param {array} times - array of time length of each image\r\n   * @param {number} cnt - total counts of gif images\r\n   * @param {array} frames - array of each image\r\n   */\r\n  __ready ({ src, times, cnt, frames }) {\r\n    log('__ready')\r\n    this.__textureSrc = src\r\n    this.__delayTimes = times\r\n    cnt ? this.__loopCnt = cnt : this.__infinity = true\r\n    this.__frames = frames\r\n    this.__frameCnt = times.length\r\n    this.__startTime = Date.now()\r\n    this.__width = THREE.Math.floorPowerOfTwo(frames[0].width)\r\n    this.__height = THREE.Math.floorPowerOfTwo(frames[0].height)\r\n    this.__cnv.width = this.__width\r\n    this.__cnv.height = this.__height\r\n    this.__draw()\r\n    if (this.__autoplay) {\r\n      this.play()\r\n    }\r\n    else {\r\n      this.pause()\r\n    }\r\n  },\r\n\r\n  /*=============================\r\n  =            reset            =\r\n  =============================*/\r\n  /**\r\n   * @private\r\n   */\r\n  __reset () {\r\n    this.pause()\r\n    this.__clearCanvas()\r\n    this.__startTime = 0\r\n    this.__nextFrameTime = 0\r\n    this.__frameIdx = 0\r\n    this.__frameCnt = 0\r\n    this.__delayTimes = null\r\n    this.__infinity = false\r\n    this.__loopCnt = 0\r\n    this.__frames = null\r\n    this.__textureSrc = null\r\n  },\r\n})\r\n"],"names":[],"sourceRoot":""}